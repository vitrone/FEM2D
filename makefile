#=============================================================================#
#                                                                             #
# Author: Vishal Vaibhav                                                      #
#                                                                             #
# Description: topmost level makefile                                         #
#                                                                             #
# History:                                                                    #
# 19 July 2013: created                                                       #
#                                                                             #
#=============================================================================#
# GNU make guide: http://www.gnu.org/software/make/manual/make.html
# 
# Rule:
# A simple makefile consists of “rules” with the following shape:
# target ... : prerequisites ...
#             recipe
#             ...
#             ...
# target: A target is usually the name of a file that is generated by a program;
# examples of targets are executable or object files. A target can also be the 
# name of an action to carry out, such as ‘clean’ (see Phony Targets).
#
# prerequisite: A prerequisite is a file that is used as input to create the 
# target. A target often depends on several files.
#
# recipe: A recipe is an action that make carries out. A recipe may have more
# than one command, either on the same line or each on its own line. 
# Please note: you need to put a tab character at the beginning of every recipe
# line! Usually a recipe is in a rule with prerequisites and serves to create a
# target file if any of the prerequisites change. However, the rule that
# specifies a recipe for the target need not have prerequisites. For example,
# the rule containing the delete command associated with the target ‘clean’
# does not have prerequisites.

# Variables: Variables can be defined using "=". SELL here is a variable whose
# values can be referenced by $(SHELL) or ${SHELL}
SHELL = /bin/sh
SUBDIRS = LIB MEXLIB

# PHONY target: A phony target is one that is not really the name of a file; 
# rather it is just a name for a recipe to be executed when you make an explicit 
# request. Note, "clean" is not really target, i.e., there is no file called "clean"
# ever created by make. By declaring "clean" as PHONY, make will ignore any
# actuall file with the name clean present in the directory and execute the
# "clean" recipe anyway. Here, subdirs and SUBDIRS are all PHONY targets.

.PHONY: subdirs $(SUBDIRS)

subdirs: $(SUBDIRS)

# Recursive make commands should always use the variable MAKE, not the explicit 
# command name "make". Look up: How the MAKE Variable Works.

# Make Option: "-C dir" or "--directory=dir"
# Change to directory dir before reading the makefiles. If multiple ‘-C’ options 
# are specified, each is interpreted relative to the previous one: ‘-C / -C etc’ is
# equivalent to ‘-C /etc’. This is typically used with recursive invocations of 
# make (see Recursive Use of make).
$(SUBDIRS):
	$(MAKE) --directory=$@	
# $(MAKE) -C $@

# Automatic Variables: "$@" above is an example of atumatic variable.
# Table of automatic variables
# $@ - The file name of the target of the rule. In a pattern rule that has 
#      multiple targets (see Introduction to Pattern Rules), ‘$@’ is the name of
#      whichever target caused the rule's recipe to be run.
# $< - The name of the first prerequisite. If the target got its recipe from an 
#      implicit rule, this will be the first prerequisite added by the implicit 
#      rule (see Implicit Rules).
# $? - The names of all the prerequisites that are newer than the target, with 
#      spaces between them.

# Building of MEXLIB requires LIB to be built first
MEXLIB : LIB


.PHONY: clean
# The syntax $$ has to do with eval function. The argument to the eval function 
# is expanded, then the results of that expansion are parsed as makefile syntax.
# It's important to realize that the eval argument is expanded twice; first by 
# the eval function, then the results of that expansion are expanded again when 
# they are parsed as makefile syntax. This means you may need to provide extra 
# levels of escaping for “$” characters when using eval.
clean: 
	for dir in $(SUBDIRS); do     \
	    echo $$dir;               \
	    $(MAKE) -C ./$$dir clean; \
	    done
